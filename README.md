# CurrencyChronicle

<div align="center">
<img src="img/logo.webp" width=70%>
</div>

<br>

<div align="center">
<img src="https://img.shields.io/badge/c++-black?style=for-the-badge&logo=cplusplus&logoColor=00599C"/>
<img src="https://img.shields.io/badge/cmake-black?style=for-the-badge&logo=cmake&logoColor=green"/>
<img src="https://img.shields.io/badge/GIT-black?style=for-the-badge&logo=GIT&logoColor=F05032"/>
<img src="https://img.shields.io/badge/CLION-black?style=for-the-badge&logo=CLION&logoColor=23A9Ad"/>
</div>

<br>

<div align="center">

[![Status](https://img.shields.io/badge/status-active-success.svg)]()
![GitHub Issues](https://img.shields.io/github/issues/k6zma/CurrencyChronicle.svg)
![GitHub Pull Requests](https://img.shields.io/github/issues-pr/k6zma/CurrencyChronicle.svg)
![Stars](https://img.shields.io/github/stars/k6zma/CurrencyChronicle.svg)

</div>

## Task:
Создать программу для работы с курсами валют. Программа должна:

1) Определять курс валюты к российскому рублю на заданную дату.
2) Определять курс валюты за указанный период.
3) Сохранять результаты в файл.

Управление программой осуществляется через командную строку с параметрами в формате `--<ключ>=<значение>`

**Основные параметры:**
- `Vname` <i>(обязательный параметр)</i>: код валюты (например, USD).
- `Vnom` <i>(обязательный параметр)</i>: номинал валюты.
- `Date`: конкретная дата, формат dd.mm.yyyy.
- `DateDate`: период, формат dd.mm.yyyy-dd.mm.yyyy.

## Solution:
Для решения использовались **две библиотеки**:

- <a href="https://github.com/libcpr/cpr"><b>`CPR`</b></a> - это легкая C++ библиотека, обеспечивающая простой и современный интерфейс для работы с HTTP-запросами, основанный на библиотеке libcurl.
- <a href="https://github.com/nlohmann/json"><b>`JSON`</b></a> - современная библиотека C++ для работы с JSON.

Используемый **API**:

- <a href="https://apilayer.com/marketplace/fixer-api?utm_source=apilayermarketplace&utm_medium=featured"><b>`FixerAPI`</b></a> - сервис для получения информации о валютных курсах, который предлагает несколько типов данных через API-запросы. Вот основные доступные эндпоинты для GET-запросов:
    
    1) **`/symbols`** - возвращает список всех доступных валют. Это полезно для идентификации поддерживаемых кодов валют в API.
    2) **`/latest`** - предоставляет данные о текущем валютном курсе для всех доступных или указанных валют. Этот эндпоинт часто используется для получения самых свежих курсов валют.
    3) **`/convert`** - позволяет конвертировать любую сумму из одной валюты в другую. Этот запрос требует указания исходной валюты, целевой валюты и суммы.
    4) **`/{date}`** - возвращает исторические данные о курсах валют на указанную дату для всех доступных или конкретных валют. Это полезно для анализа изменений курсов на конкретную дату в прошлом
    5) **`/timeseries`** - предоставляет данные о ежедневных исторических курсах валют между двумя указанными датами для всех доступных или конкретных валют. Этот запрос полезен для анализа тенденций и изменений курсов валют в течение определённого периода времени.
    6) **`/fluctuation`** - возвращает данные о колебаниях курсов валют между двумя указанными датами. Это включает информацию о минимальных, максимальных значениях курса и процентных изменениях.

## Theory:
- ### C++ Theory:
   `std::string` — это класс в стандартной библиотеке C++, который представляет собой динамический массив символов.

   `std::string` динамически управляет своей памятью, используя техники, подобные динамическому массиву. Под капотом `std::string` обычно содержит три основных элемента:
    - Указатель на массив символов, который фактически содержит строковые данные.
    - Размер, указывающий на количество символов в строке.
    - Вместимость, показывающая, сколько символов может храниться в выделенном массиве, прежде чем потребуется его расширение.

    Когда строка расширяется и текущая вместимость недостаточна для новых данных, `std::string` обычно выделяет новый, больший блок памяти, копирует существующие данные в новое место и освобождает старую память.

    **Методы, которые использовались:**
    - `find` ищет подстроку или символ в строке и возвращает позицию первого вхождения этой подстроки или символа и возвращает позицию начала первого вхождения подстроки или `std::string::npos`, если подстрока не найдена.
    - `substr` возвращает новую строку, которая является подстрокой исходной строки, возвращает подстроку от позиции `pos` длиной `len`. Если `len` больше оставшейся длины строки от `pos`, возвращается подстрока до конца строки.
    - `npos` — это статическая константа в классе `std::string`, которая представляет наибольшее возможное значение для `size_t` и используется для индикации отсутствия позиций.
    - `stoi` конвертирует строку в целое число, возвращает целое число, полученное из строки, генерирует исключение `std::invalid_argument`, если строка не содержит числовых данных.
    - `replace` заменяет часть строки другой строкой, метод модифицирует исходную строку, заменяя указанный диапазон символов новой подстрокой, метод возвращает ссылку на измененную строку `(*this)`.

    Аргументы командной строки в `C++` предоставляют возможность передавать внешние данные в программу при её запуске. Эти данные обрабатываются через два основных параметра функции `main`: `int argc` и `char* argv[]`:
    
    - `argc` (от "<i>argument count</i>") — это переменная типа `int`, которая содержит количество аргументов, переданных программе, включая имя самой программы. 
    - `argv` (от "<i>argument vector</i>") — это массив указателей на `char`. Каждый элемент этого массива (`argv[0]`, `argv[1]`, ..., `argv[argc-1]`) является указателем на строку типа `char*`, которая содержит один из аргументов, переданных программе

    Функция `exit` используется в C++ для немедленного завершения программы. Эта функция принимает один аргумент типа `int`, который указывает операционной системе статус завершения программы. Этот статус может быть использован скриптами или другими программами, которые вызывали данное приложение, для определения того, как программа завершилась (нормально или с ошибкой).

    - `exit(0)` обычно указывает на то, что программа завершила свою работу успешно и без ошибок.
    - `exit(1)` или любое другое ненулевое значение часто используется для указания на то, что в процессе выполнения программы произошла ошибка.

    Когда вызывается `exit`, происходит:
    1. Вызов деструкторов для всех объектов с статическим временем жизни.
    2. Закрытие всех открытых файловых дескрипторов и освобождение других системных ресурсов.
    3. Возврат управления операционной системе с кодом завершения, указанным в аргументе.

    `std::cerr` — это стандартный поток вывода ошибок в C++. Он используется для вывода сообщений об ошибках и другой диагностической информации. В отличие от `std::cout`, который предназначен для обычного вывода данных, `std::cerr` не использует буферизацию, что означает, что все сообщения, отправленные в `std::cerr`, выводятся немедленно. Это особенно важно для сообщений об ошибках, поскольку при возникновении критической ошибки, ведущей к аварийному завершению программы, информация должна быть выведена без задержек.

    В `C++`, ключевое слово `auto` используется для автоматического определения типа переменной на основе типа её инициализатора. 
    Когда используется `auto`, компилятор анализирует выражение на правой стороне оператора присваивания и автоматически определяет его тип. Затем этот тип присваивается переменной на левой стороне.

    `Range-based for loop` — это удобный способ итерирования по элементам контейнера или по любому диапазону, поддерживающему итерацию.

    На машинном уровне `range-based for loop` в C++ работает аналогично традиционным циклам с использованием итераторов, но с автоматическим управлением итерациями. Компилятор трансформирует `range-based for loop` в цикл с использованием итераторов. 

    **Минусы `range-based for loop`**:
    1) Ограниченный контроль над итерацией:
     В отличие от традиционных циклов `for`, в range-based for loop невозможно управлять инкрементом итератора более гибко (например, пропускать элементы или итерировать в обратном порядке без дополнительной подготовки).
    2) Производительность при неоптимальном использовании: 
     Если элементы контейнера копируются вместо использования ссылок, это может привести к ненужному перерасходу ресурсов, особенно если элементы контейнера являются большими или дорогостоящими для копирования объектами.
    3) Требования к типам: 
     Циклы на основе диапазона требуют, чтобы тип, по которому происходит итерация, имел определенные методы `(begin() и end())`.

    `std::fstream` является частью стандартной библиотеки ввода-вывода `C++` и используется для работы с файлами. Этот класс обеспечивает функционал для чтения и записи файлов и является производным от `std::iostream`, сочетая функциональность `std::ifstream` для ввода из файла <i>(чтения)</i> и `std::ofstream` для вывода в файл <i>(записи)</i>.

    Оператор `<<` используется для записи данных в файл. Этот оператор, когда применяется к объекту `std::fstream`, позволяет направлять данные различных типов <i>(числа, строки и т.д.)</i> непосредственно в файл.

    `std::ios::out` — это флаг, используемый в стандартной библиотеке ввода-вывода C++ для указания режима работы с файлом. Этот флаг часть перечисления, которое определяет различные режимы доступа и операций с потоками данных. 

    Ввод и вывод в `std::fstream` обычно буферизуются. Это значит, что данные сначала собираются в буфере, а затем пишутся в файл или читаются из файла блоками. Это уменьшает количество дорогостоящих операций ввода-вывода на уровне операционной системы и повышает производительность.

- ### API Theory:
    `API` – это набор правил, протоколов и инструментов, которые позволяют различным программным приложениям взаимодействовать друг с другом. API определяет, как программы могут взаимодействовать с определенными системами, приложениями или библиотеками, облегчая разработку программного обеспечения и интеграцию различных служб. Он служит мостом между различными программными компонентами или между программой и операционной системой или сетевыми службами.

    `REST` – это архитектурный стиль, который обычно используется для создания сетевых приложений. `REST API` основан на использовании стандартных HTTP-методов, таких как `GET`, `POST`, `PUT` и `DELETE`, и ориентирован на ресурсы, где каждый `URL` представляет собой объект (ресурс), с которым можно взаимодействовать.

    `SOAP` – это протокол, который определяет, как два объекта в разных процессах могут общаться по сети. `SOAP API` основан на `XML` и предоставляет более строгий и безопасный способ взаимодействия по сравнению с `REST`. 

    `HTTP-методы`, также известные как `HTTP-глаголы`, являются важным компонентом в архитектуре клиент-серверного общения в сети интернет. Они определяют тип операции, которую клиент желает выполнить на сервере, и являются фундаментальной частью протокола `HTTP`. Каждый метод указывает на конкретное действие, предполагаемое для ресурса (например, веб-страницы, сервера, веб-приложения).

    Метод `GET` используется для запроса данных с сервера. Он предназначен только для получения данных и не должен влиять на состояние данных на сервере, то есть не изменять их. В идеале, запросы `GET` могут быть кэшируемыми, и результаты одного и того же запроса `GET` должны быть одинаковыми при многократном их выполнении.

    Метод `POST` используется для отправки данных на сервер для создания нового объекта. `POST`-запросы не кэшируются и не остаются идентичными при повторных отправках

    Метод `PUT` используется для отправки данных на сервер для обновления существующего объекта целиком. Если объект не существует, он может быть создан. `PUT`-запросы также не кэшируются.

    Метод `DELETE` используется для удаления существующего объекта. Это должно привести к удалению указанного ресурса, если он существует.

    `Curl` является мощным и широко используемым инструментом командной строки для передачи данных с использованием различных протоколов сетевого уровня.

    На высоком уровне `curl` предоставляет интерфейс для создания запросов к серверам и получения ответов. Он может использоваться для загрузки или отправки данных, и это делает его полезным для многих задач, таких как `API-запросы`, удаленное управление данными и автоматизированное тестирование веб-приложений.

    **Основные возможности Curl:**
    - Отправка запросов: `Curl` может создавать разнообразные типы запросов (`GET`, `POST`, `PUT` и т. д.), позволяя тонко настраивать заголовки, методы, тело запроса и другие `HTTP-атрибуты`.
    - Загрузка и отправка файлов: Поддержка протоколов, таких как `FTP` и `SFTP`, позволяет использовать `curl` для загрузки или отправки файлов на серверы или из серверов.

    `JSON` — это легкий формат обмена данными, который легко читается и пишется людьми, а также легко анализируется и генерируется машинами.

    `JSON` часто используется для сериализации и передачи структурированных данных по сети, особенно при обмене данными между клиентом и сервером в веб-приложениях. Он обычно служит альтернативой более тяжеловесным форматам, таким как `XML`.

    На высоком уровне `JSON` используется для представления данных в структурированном, иерархическом формате. Он поддерживает следующие типы данных:

    - `Объекты`: Набор пар ключ/значение, где ключ должен быть строкой, а значение может быть любым типом данных `JSON`. Объекты в `JSON` обозначаются фигурными скобками {}.
    - `Массивы`: Упорядоченные списки значений (которые также могут быть любым типом данных JSON). Массивы обозначаются квадратными скобками `[]`.
    - `Примитивы`: Строки, числа, булевы значения (true и false) и null.

- ### CMake Theory:
    `CMake` — это кроссплатформенная система автоматизации сборки программного обеспечения, которая использует текстовые файлы (называемые `CMakeLists.txt`) для определения процесса сборки в не зависящих от платформы и компилятора терминах.

    `cmake_minimum_required(VERSION 3.27)` - эта команда устанавливает минимально требуемую версию `CMake` для проекта. Она гарантирует, что используется достаточно новая версия `CMake`, поддерживающая все необходимые функции и команды.

    `project(CurrencyChronicle)` - команда `project` задает имя проекта и необязательно версию, описание и другие характеристики. Это имя используется в документации, генерации исполняемых файлов и других частях процесса сборки.

    `include(FetchContent)` - команда `include` загружает и запускает `CMake-код` из файла или модуля. В данном случае `FetchContent` — это модуль, который упрощает загрузку исходного кода (или другого контента) во время фазы конфигурации сборки.

    `FetchContent_Declare` используется для объявления внешних библиотек, указывая, где и как их можно загрузить. В вашем случае, это библиотеки `cpr` и `json`. `FetchContent_MakeAvailable` выполняет всю работу по загрузке, обновлению и подготовке объявленного содержимого к использованию в проекте.

    `set(CMAKE_CXX_STANDARD 17)` - эта команда устанавливает стандарт `C++` для всего проекта. `CMAKE_CXX_STANDARD 17` означает использование стандарта `C++17`.

    `add_executable(CurrencyChronicle main.cpp)` - команда `add_executable` создает исполняемый файл с именем `CurrencyChronicle` из указанного исходного файла `main.cpp`.

    `target_link_libraries(CurrencyChronicle PRIVATE cpr::cpr)` - `target_link_libraries` связывает библиотеку с целевым исполняемым файлом. В этом случае, это библиотека `cpr` и `json`, которая используется в проекте в качестве частной зависимости (`PRIVATE`), что означает, что она используется только в данной цели, и не влияет на другие цели, которые могут ссылаться на текущую цель.

    